<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="How openGL work"><meta name="keywords" content="openGL,graphics"><meta name="author" content="方镇澎"><meta name="copyright" content="方镇澎"><title>How openGL work | 方镇澎的博客</title><link rel="shortcut icon" href="/favicon.svg"><link rel="stylesheet" href="/css/index.css?version=1.9.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.3"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%B7%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">起点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E7%BA%BF%E6%B8%B2%E6%9F%93"><span class="toc-number">2.</span> <span class="toc-text">直线渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E6%B8%B2%E6%9F%93"><span class="toc-number">3.</span> <span class="toc-text">三角形渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2-z-buffer"><span class="toc-number">4.</span> <span class="toc-text">深度缓冲(z-buffer)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1"><span class="toc-number">5.</span> <span class="toc-text">透视投影</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E9%95%9C%E5%A4%B4"><span class="toc-number">6.</span> <span class="toc-text">移动镜头</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%A2%E5%9F%BA"><span class="toc-number">6.1.</span> <span class="toc-text">换基</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%95%E5%90%91%E9%87%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.2.</span> <span class="toc-text">法向量转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8-shader"><span class="toc-number">7.</span> <span class="toc-text">着色器(shader)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86"><span class="toc-number">7.1.</span> <span class="toc-text">纹理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1"><span class="toc-number">8.</span> <span class="toc-text">阴影</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%85%89%E9%81%AE%E8%94%BD%EF%BC%88Ambient-occlusion%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">环境光遮蔽（Ambient occlusion）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">暴力方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%8E%AF%E5%A2%83%E5%85%89%E9%81%AE%E8%94%BD"><span class="toc-number">9.2.</span> <span class="toc-text">屏幕空间环境光遮蔽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">引用</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">方镇澎</div><div class="author-info__description text-center">方镇澎 Blog Slides</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">19</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">34</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">方镇澎的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">How openGL work</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-24</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本文的主要内容都来自于对<a href="#jump">1</a>的学习和整理。从画点开始介绍openGL的工作原理。</p>
<a id="more"></a>

<h2 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h2><p>我们的目的是了解openGL的工作原理，重心是如何将三维模型渲染到二维的平面上，不是如何建立三维模型。所以，我们一开始只拥有两样东西，一样是格式为TGA的三维模型文件, 另一样是可以在像素点是涂上颜色的函数。</p>
<p>比如，下面的代码将一个像素点染色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tgaimage.h&quot;</span></span></span><br><span class="line"><span class="keyword">const</span> TGAColor white = TGAColor(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line"><span class="keyword">const</span> TGAColor red   = TGAColor(<span class="number">255</span>, <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">255</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">        <span class="function">TGAImage <span class="title">image</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>, TGAImage::RGB)</span></span>;</span><br><span class="line">        image.<span class="built_in">set</span>(<span class="number">52</span>, <span class="number">41</span>, red);</span><br><span class="line">        image.flip_vertically(); <span class="comment">// i want to have the origin at the left bottom corner of the image</span></span><br><span class="line">        image.write_tga_file(<span class="string">&quot;output.tga&quot;</span>);`</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的代码都在这个<a target="_blank" rel="noopener" href="https://github.com/ssloy/tinyrenderer">仓库</a>中。</p>
<h2 id="直线渲染"><a href="#直线渲染" class="headerlink" title="直线渲染"></a>直线渲染</h2><p>已知两个点确定一条直线。公式如下：<br>$$ y=y_0 + (y_1 - y_0)/(x_1 - x_0)*(x - x_0) $$</p>
<p>根据上面公式,我们可以写出下面的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">line</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, TGAImage &amp;image, TGAColor color)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x=x0; x&lt;=x1; x++) &#123; </span><br><span class="line">        <span class="keyword">int</span> y = y0 + (y1 - y0)/(x1 - x0)*(x - x0); </span><br><span class="line">        image.<span class="built_in">set</span>(x, y, color); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码有好几个问题，先不考虑数据类型导致的精度丢失和除零错。跟画图相关的问题有两个。</p>
<ol>
<li>for循环蕴含了x0&lt;=x1</li>
<li>如果直线斜率过大，两个点的在y轴上的差值大于1，渲染出来的直线呈点状。如下图所示。</li>
</ol>
<p><img src="line.png" alt="line.png"></p>
<p>因此在画图前需要对点和坐标做一定的处理。修改后的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">line</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, TGAImage &amp;image, TGAColor color)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">bool</span> steep = <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(x0-x1)&lt;<span class="built_in">std</span>::<span class="built_in">abs</span>(y0-y1)) &#123; <span class="comment">// if the line is steep, we transpose the image </span></span><br><span class="line">        <span class="built_in">std</span>::swap(x0, y0); </span><br><span class="line">        <span class="built_in">std</span>::swap(x1, y1); </span><br><span class="line">        steep = <span class="literal">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (x0&gt;x1) &#123; <span class="comment">// make it left−to−right </span></span><br><span class="line">        <span class="built_in">std</span>::swap(x0, x1); </span><br><span class="line">        <span class="built_in">std</span>::swap(y0, y1); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x=x0; x&lt;=x1; x++) &#123; </span><br><span class="line">        <span class="keyword">int</span> y = y0 + (y1 - y0)/(x1 - x0)*(x - x0); </span><br><span class="line">        <span class="keyword">if</span> (steep) &#123; </span><br><span class="line">            image.<span class="built_in">set</span>(y, x, color); <span class="comment">// if transposed, de−transpose </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            image.<span class="built_in">set</span>(x, y, color); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于每两个在x轴上连续的像素点只相差1，所以我们的代码可以优化如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">line</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, TGAImage &amp;image, TGAColor color)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">bool</span> steep = <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(x0-x1)&lt;<span class="built_in">std</span>::<span class="built_in">abs</span>(y0-y1)) &#123; </span><br><span class="line">        <span class="built_in">std</span>::swap(x0, y0); </span><br><span class="line">        <span class="built_in">std</span>::swap(x1, y1); </span><br><span class="line">        steep = <span class="literal">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (x0&gt;x1) &#123; </span><br><span class="line">        <span class="built_in">std</span>::swap(x0, x1); </span><br><span class="line">        <span class="built_in">std</span>::swap(y0, y1); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> dx = x1-x0; </span><br><span class="line">    <span class="keyword">int</span> dy = y1-y0; </span><br><span class="line">    <span class="keyword">float</span> derror = <span class="built_in">std</span>::<span class="built_in">abs</span>(dy/<span class="keyword">float</span>(dx)); </span><br><span class="line">    <span class="keyword">float</span> error = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> y = y0; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x=x0; x&lt;=x1; x++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (steep) &#123; </span><br><span class="line">            image.<span class="built_in">set</span>(y, x, color); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            image.<span class="built_in">set</span>(x, y, color); </span><br><span class="line">        &#125; </span><br><span class="line">        error += derror; </span><br><span class="line">        <span class="keyword">if</span> (error&gt;<span class="number">.5</span>) &#123; </span><br><span class="line">            y += (y1&gt;y0?<span class="number">1</span>:<span class="number">-1</span>); </span><br><span class="line">            error -= <span class="number">1.</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>只有当累计误差大于0.5的时候下一个点的y值加减1。</p>
<p>现在再来解决除零错和浮点类型的问题。方法是将误差值乘以2*dx。下面是我最终的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">line</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, TGAImage &amp;image, TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> isSteep = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(x1 - x0) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(y1 - y0))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(x0, y0);</span><br><span class="line">		<span class="built_in">std</span>::swap(x1, y1);</span><br><span class="line">		isSteep = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (x0 &gt; x1)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(x0, x1);</span><br><span class="line">		<span class="built_in">std</span>::swap(y0, y1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> y = y0;</span><br><span class="line">	<span class="keyword">int</span> derror = <span class="number">2</span> * <span class="built_in">std</span>::<span class="built_in">abs</span>(y1 - y0);</span><br><span class="line">	<span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = x0; x &lt;= x1; x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (isSteep)</span><br><span class="line">		&#123;</span><br><span class="line">			image.<span class="built_in">set</span>(y, x, color);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			image.<span class="built_in">set</span>(x, y, color);</span><br><span class="line">		&#125;</span><br><span class="line">		error += derror;</span><br><span class="line">		<span class="keyword">if</span> (error + x0 &gt;= x1)</span><br><span class="line">		&#123;</span><br><span class="line">			y += y1 &gt; y0 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">			error -= <span class="number">2</span> * (x1 - x0);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三角形渲染"><a href="#三角形渲染" class="headerlink" title="三角形渲染"></a>三角形渲染</h2><p>渲染完直线后，下一步是三角形，三维模型都是由三角形构建出来的，因此三角形的渲染是比较重要的。</p>
<p>三角形的渲染就是把三条线围住的像素点着色。</p>
<p>最容易想到的着色方法是线扫描算法。顾名思义，就是一行一行地把像素点染色。算法麻烦的地方在于找出需要着色像素的起点和终点。</p>
<p>这个方法不详细介绍了，直接给出代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage &amp;image, TGAColor color)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (t0.y==t1.y &amp;&amp; t0.y==t2.y) <span class="keyword">return</span>; <span class="comment">// I dont care about degenerate triangles </span></span><br><span class="line">    <span class="comment">// sort the vertices, t0, t1, t2 lower−to−upper (bubblesort yay!) </span></span><br><span class="line">    <span class="keyword">if</span> (t0.y&gt;t1.y) <span class="built_in">std</span>::swap(t0, t1); </span><br><span class="line">    <span class="keyword">if</span> (t0.y&gt;t2.y) <span class="built_in">std</span>::swap(t0, t2); </span><br><span class="line">    <span class="keyword">if</span> (t1.y&gt;t2.y) <span class="built_in">std</span>::swap(t1, t2); </span><br><span class="line">    <span class="keyword">int</span> total_height = t2.y-t0.y; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;total_height; i++) &#123; </span><br><span class="line">        <span class="keyword">bool</span> second_half = i&gt;t1.y-t0.y || t1.y==t0.y; </span><br><span class="line">        <span class="keyword">int</span> segment_height = second_half ? t2.y-t1.y : t1.y-t0.y; </span><br><span class="line">        <span class="keyword">float</span> alpha = (<span class="keyword">float</span>)i/total_height; </span><br><span class="line">        <span class="keyword">float</span> beta  = (<span class="keyword">float</span>)(i-(second_half ? t1.y-t0.y : <span class="number">0</span>))/segment_height; <span class="comment">// be careful: with above conditions no division by zero here </span></span><br><span class="line">        Vec2i A =               t0 + (t2-t0)*alpha; </span><br><span class="line">        Vec2i B = second_half ? t1 + (t2-t1)*beta : t0 + (t1-t0)*beta; </span><br><span class="line">        <span class="keyword">if</span> (A.x&gt;B.x) <span class="built_in">std</span>::swap(A, B); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=A.x; j&lt;=B.x; j++) &#123; </span><br><span class="line">            image.<span class="built_in">set</span>(j, t0.y+i, color); <span class="comment">// attention, due to int casts t0.y+i != A.y </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在现实中，我们可能需要一些更容易在成千上万线程中并行渲染的方法。这意味着这个算法需要能够很容易地将大问题切分成很多的小问题。因此有时候我们需要一些看上去很“白痴”的方法。比如下面的伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">triangle(vec2 points[<span class="number">3</span>]) &#123; </span><br><span class="line">    vec2 bbox[<span class="number">2</span>] = find_bounding_box(points); </span><br><span class="line">    <span class="keyword">for</span> (each pixel in the bounding box) &#123; </span><br><span class="line">        <span class="keyword">if</span> (inside(points, pixel)) &#123; </span><br><span class="line">            put_pixel(pixel); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法先找到一个方框将三角形圈起来。然后判断每个点是否需要染色。</p>
<p>方法的难点在于如何判断一个像素点是否在三角形中，这时候我们就需要<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">重心坐标</a>。</p>
<p>重心坐标在平面上即用三角形的三个顶点来表示坐标。设三个顶点为A,B,C。P为平面上一点。</p>
<p>若P=xA+yB+zC 且 x+y+z=1。那么(x,y,z)就是P的重心坐标。</p>
<p>重心坐标有个重要的性质，三角形中的点在重点坐标中的坐标值都/大于0。利用这个性质就可以判断点是否在三角形中。</p>
<p>剩下的问题就是如何将直角坐标转换为重心坐标了。</p>
<p>根据定义可得</p>
<p>$$ p=(1-y-z)A+yB+zC $$</p>
<p>化简得</p>
<p>$$ y\vec{BA}+z\vec{CA}+\vec{AP} = 0 $$</p>
<p>即</p>
<p>$$ y\vec{BA}_x+z\vec{CA}_x+\vec{AP}_x = 0 $$<br>$$ y\vec{BA}_y+z\vec{CA}_y+\vec{AP}_y = 0 $$</p>
<p>所以(y,z,1) 和 (\vec{BA}_x,\vec{CA}_x,\vec{AP}_x)(\vec{BA}_y,\vec{CA}_y,\vec{AP}_y)都正交。</p>
<p>所以(y,z,1) 可以通过后两者得叉乘得到。下面是求重心坐标和渲染三角形的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3f <span class="title">barycentric</span><span class="params">(Vec2i *pts, Vec2i P)</span> </span>&#123; </span><br><span class="line">    Vec3f u = cross(Vec3f(pts[<span class="number">2</span>][<span class="number">0</span>]-pts[<span class="number">0</span>][<span class="number">0</span>], pts[<span class="number">1</span>][<span class="number">0</span>]-pts[<span class="number">0</span>][<span class="number">0</span>], pts[<span class="number">0</span>][<span class="number">0</span>]-P[<span class="number">0</span>]), Vec3f(pts[<span class="number">2</span>][<span class="number">1</span>]-pts[<span class="number">0</span>][<span class="number">1</span>], pts[<span class="number">1</span>][<span class="number">1</span>]-pts[<span class="number">0</span>][<span class="number">1</span>], pts[<span class="number">0</span>][<span class="number">1</span>]-P[<span class="number">1</span>]));</span><br><span class="line">    <span class="comment">/* `pts` and `P` has integer value as coordinates</span></span><br><span class="line"><span class="comment">       so `abs(u[2])` &lt; 1 means `u[2]` is 0, that means</span></span><br><span class="line"><span class="comment">       triangle is degenerate, in this case return something with negative coordinates */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(u[<span class="number">2</span>])&lt;<span class="number">1</span>) <span class="keyword">return</span> Vec3f(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Vec3f(<span class="number">1.f</span>-(u.x+u.y)/u.z, u.y/u.z, u.x/u.z); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i *pts, TGAImage &amp;image, TGAColor color)</span> </span>&#123; </span><br><span class="line">    <span class="function">Vec2i <span class="title">bboxmin</span><span class="params">(image.get_width()<span class="number">-1</span>,  image.get_height()<span class="number">-1</span>)</span></span>; </span><br><span class="line">    <span class="function">Vec2i <span class="title">bboxmax</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>; </span><br><span class="line">    <span class="function">Vec2i <span class="title">clamp</span><span class="params">(image.get_width()<span class="number">-1</span>, image.get_height()<span class="number">-1</span>)</span></span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">2</span>; j++) &#123; </span><br><span class="line">            bboxmin[j] = <span class="built_in">std</span>::max(<span class="number">0</span>,        <span class="built_in">std</span>::min(bboxmin[j], pts[i][j])); </span><br><span class="line">            bboxmax[j] = <span class="built_in">std</span>::min(clamp[j], <span class="built_in">std</span>::max(bboxmax[j], pts[i][j])); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    Vec2i P; </span><br><span class="line">    <span class="keyword">for</span> (P.x=bboxmin.x; P.x&lt;=bboxmax.x; P.x++) &#123; </span><br><span class="line">        <span class="keyword">for</span> (P.y=bboxmin.y; P.y&lt;=bboxmax.y; P.y++) &#123; </span><br><span class="line">            Vec3f bc_screen  = barycentric(pts, P); </span><br><span class="line">            <span class="keyword">if</span> (bc_screen.x&lt;<span class="number">0</span> || bc_screen.y&lt;<span class="number">0</span> || bc_screen.z&lt;<span class="number">0</span>) <span class="keyword">continue</span>; </span><br><span class="line">            image.<span class="built_in">set</span>(P.x, P.y, color); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在渲染三角形的过程中，我们还需要考虑每个三角形的着色。三维模型的颜色又跟纹理和光照强度有关系。</p>
<p>我们先考虑光照强度的影响。光照强度等于光向量和平面法向量的点积。下面是考虑光照强度后的渲染代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;model-&gt;nfaces(); i++) &#123; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; face = model-&gt;face(i); </span><br><span class="line">    Vec2i screen_coords[<span class="number">3</span>]; </span><br><span class="line">    Vec3f world_coords[<span class="number">3</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++) &#123; </span><br><span class="line">        Vec3f v = model-&gt;vert(face[j]); </span><br><span class="line">        screen_coords[j] = Vec2i((v.x+<span class="number">1.</span>)*width/<span class="number">2.</span>, (v.y+<span class="number">1.</span>)*height/<span class="number">2.</span>); </span><br><span class="line">        world_coords[j]  = v; </span><br><span class="line">    &#125; </span><br><span class="line">    Vec3f n = (world_coords[<span class="number">2</span>]-world_coords[<span class="number">0</span>])^(world_coords[<span class="number">1</span>]-world_coords[<span class="number">0</span>]); </span><br><span class="line">    n.normalize(); </span><br><span class="line">    <span class="keyword">float</span> intensity = n*light_dir; </span><br><span class="line">    <span class="keyword">if</span> (intensity&gt;<span class="number">0</span>) &#123; </span><br><span class="line">        triangle(screen_coords[<span class="number">0</span>], screen_coords[<span class="number">1</span>], screen_coords[<span class="number">2</span>], image, TGAColor(intensity*<span class="number">255</span>, intensity*<span class="number">255</span>, intensity*<span class="number">255</span>, <span class="number">255</span>)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是通过上面代码渲染出来的一个模型。</p>
<p><img src="head.png" alt="head.png"></p>
<p>在模型中，口的内腔部分画在了嘴唇上，这是因为我们将原本不可见的部分覆盖在了可见的部分上。</p>
<h2 id="深度缓冲-z-buffer"><a href="#深度缓冲-z-buffer" class="headerlink" title="深度缓冲(z-buffer)"></a>深度缓冲(z-buffer)</h2><p>深度缓冲的概念很简单。就是用一段内存空间将同一像素点对应的多个点在z轴上的最大值缓存起来。只渲染z轴上值最大那个点。</p>
<p>代码改动比较少，我写的代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec3i *pts, TGAImage &amp;image, TGAColor color, <span class="keyword">int</span> *zbuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::sort(pts, pts + <span class="number">3</span>, [](Vec3i a, Vec3i b) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> a.x &lt; b.x; &#125;);</span><br><span class="line">	<span class="keyword">int</span> smallx = pts[<span class="number">0</span>].x;</span><br><span class="line">	<span class="keyword">int</span> largex = pts[<span class="number">2</span>].x;</span><br><span class="line">	<span class="built_in">std</span>::sort(pts, pts + <span class="number">3</span>, [](Vec3i a, Vec3i b) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> a.y &lt; b.y; &#125;);</span><br><span class="line">	<span class="keyword">int</span> smally = pts[<span class="number">0</span>].y;</span><br><span class="line">	<span class="keyword">int</span> largey = pts[<span class="number">2</span>].y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = smallx; x &lt;= largex; x++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> y = smally; y &lt;= largey; y++)</span><br><span class="line">		&#123;</span><br><span class="line">			Vec3f bc_screen = barycentric(pts, Vec2i(x, y));</span><br><span class="line">			<span class="keyword">if</span> (bc_screen.x &lt; <span class="number">0</span> || bc_screen.y &lt; <span class="number">0</span> || bc_screen.z &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">float</span> z = bc_screen * Vec3f(pts[<span class="number">0</span>].z, pts[<span class="number">1</span>].z, pts[<span class="number">2</span>].z);</span><br><span class="line">			<span class="keyword">if</span> (zbuffer[x + width * y] &lt; z)</span><br><span class="line">			&#123;</span><br><span class="line">				zbuffer[x + width * y] = z;</span><br><span class="line">				image.<span class="built_in">set</span>(x, y, color);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h2><p>图形运动造成的变化可以转化为各种几何变换。</p>
<p>线性变换(如旋转缩放）可以写成矩阵A和点x的乘积</p>
<p>$$ f(x)=Ax $$</p>
<p>平移变换可以写成点x和向量b加法</p>
<p>$$ f(x)=x+b $$</p>
<p>两者结合称为仿射变换，写成</p>
<p>$$ f(x)=Ax+b $$</p>
<p>如果两个仿射变换叠加</p>
<p>$$ f_1(f(x))=A(A_1x+b_1)+b $$</p>
<p>这个表达式非常丑，如果叠加更多的仿射变换会变得更加复杂。这十分不利于理解和运算。</p>
<p>解决方法是引入齐次坐标系。意思是增加一维坐标。</p>
<p>比如在平面上,仿射变换是这样表示的</p>
<p>$$<br> \left[<br> \begin{matrix}<br>   a &amp; b \<br>   c &amp; d<br>  \end{matrix}<br>  \right]<br>  \left[<br> \begin{matrix}<br>   x \<br>   y<br>  \end{matrix}<br>  \right] +<br>  \left[<br> \begin{matrix}<br>   e \<br>   f<br>  \end{matrix}<br>  \right] =<br>  \left[<br> \begin{matrix}<br>   ax+by+e \<br>   cx+dy+f<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>在齐次坐标系上我们增加一维，变成</p>
<p>$$<br> \left[<br> \begin{matrix}<br>   a &amp; b &amp; e \<br>   c &amp; d &amp; f \<br>   0 &amp; 0 &amp; 1<br>  \end{matrix}<br>  \right]<br>  \left[<br> \begin{matrix}<br>   x \<br>   y \<br>   1 \<br>  \end{matrix}<br>  \right] =<br>  \left[<br> \begin{matrix}<br>   ax+by+e \<br>   cx+dy+f \<br>   1<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>这样仿射变换的叠加就变成了矩阵的相乘，从齐次坐标变回直角坐标也很简单</p>
<p>$$<br>  \left[<br>  \begin{matrix}<br>   x \<br>   y \<br>   z \<br>  \end{matrix}<br>  \right] \to<br>  \left[<br> \begin{matrix}<br>   x/z \<br>   y/z \<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>在坐标系中相当于三维坐标的点中心投影到z=1的平面上。如图所示</p>
<p><img src="homogeneous.png" alt="homogeneous.png"></p>
<p>在这种投影方法上，我们发现z=0平面上的点对应的是z=1平面上的点的无穷远点。</p>
<p>而且我们现在可以区分出向量和点这两个概念了。<br>在直角坐标系中，(x,y)可以是点也可以是向量。<br>在齐次坐标系中，(x,y,0)代表向量，(x,y,z) z!=0 代表点。</p>
<p>回到三维的世界中， 三维直角坐标可以用四维齐次坐标表示。</p>
<p>如图所示，我们将P点映射到平面z=0上。</p>
<p><img src="projection.png" alt="projection.png"></p>
<p>可以求出</p>
<p>$$ x^{‘} = x/(1-z/c) $$ </p>
<p>$$ y^{‘} = y/(1-z/c) $$ </p>
<p>转化为齐次坐标的矩阵就是</p>
<p>$$<br> \left[<br> \begin{matrix}<br>   1 &amp; 0 &amp; 0 &amp; 0 \<br>   0 &amp; 1 &amp; 0 &amp; 0 \<br>   0 &amp; 0 &amp; 1 &amp; 0 \<br>   0 &amp; 0 &amp; r &amp; 1<br>  \end{matrix}<br>  \right]<br>  \left[<br> \begin{matrix}<br>   x \<br>   y \<br>   z \<br>   1 \<br>  \end{matrix}<br>  \right] =<br>  \left[<br> \begin{matrix}<br>   x \<br>   y \<br>   z \<br>   rz+1<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>其中$$r=-1/c$$</p>
<h2 id="移动镜头"><a href="#移动镜头" class="headerlink" title="移动镜头"></a>移动镜头</h2><p>移动镜头对应的是坐标转换。</p>
<h3 id="换基"><a href="#换基" class="headerlink" title="换基"></a>换基</h3><p>在3维欧拉空间中，换基操作如图所示</p>
<p><img src="change.png" alt="change.png"></p>
<p>其中<br>$$ \vec{op} =\vec{oo’}+\vec{o’p} $$</p>
<p>换成坐标表示<br>$$<br>\vec{op} =<br>  \left[<br> \begin{matrix}<br>   \vec{i},\vec{j},\vec{k}<br>  \end{matrix}<br>  \right]<br>  \left[<br> \begin{matrix}<br>   o’_x \<br>   o’_y \<br>   o’_z \<br>  \end{matrix}<br>  \right] +<br>  \left[<br> \begin{matrix}<br>   \vec{i’},\vec{j’},\vec{k’}<br>  \end{matrix}<br>  \right]<br>  \left[<br> \begin{matrix}<br>   p’_x \<br>   p’_y \<br>   p’_z \<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>令</p>
<p>$$<br>  \left[<br> \begin{matrix}<br>   \vec{i’},\vec{j’},\vec{k’}<br>  \end{matrix}<br>  \right] =<br>  \left[<br> \begin{matrix}<br>   \vec{i},\vec{j},\vec{k}<br>  \end{matrix}<br>  \right] * M<br>$$</p>
<p>那么<br>$$<br>\vec{op} =<br>  \left[<br> \begin{matrix}<br>   \vec{i},\vec{j},\vec{k}<br>  \end{matrix}<br>  \right]<br>  \left(<br>  \left[<br> \begin{matrix}<br>   o’_x \<br>   o’_y \<br>   o’_z \<br>  \end{matrix}<br>  \right] +<br>  M<br>  \left[<br> \begin{matrix}<br>   p’_x \<br>   p’_y \<br>   p’_z \<br>  \end{matrix}<br>  \right]<br>  \right)<br>$$</p>
<p>所以</p>
<p>$$<br>\left[<br> \begin{matrix}<br>   x \<br>   y \<br>   z \<br>  \end{matrix}<br>  \right] =<br>  \left[<br> \begin{matrix}<br>   o’_x \<br>   o’_y \<br>   o’_z \<br>  \end{matrix}<br>  \right] +<br>  M<br>  \left[<br> \begin{matrix}<br>   p’_x \<br>   p’_y \<br>   p’_z \<br>  \end{matrix}<br>  \right]<br>  \rArr<br>  \left[<br> \begin{matrix}<br>   x’ \<br>   y’ \<br>   z’ \<br>  \end{matrix}<br>  \right] =<br>  M *\left(<br>  \left[<br> \begin{matrix}<br>   p_x \<br>   p_y \<br>   p_z \<br>  \end{matrix}<br>  \right] -<br>  \left[<br> \begin{matrix}<br>   o’_x \<br>   o’_y \<br>   o’_z \<br>  \end{matrix}<br>  \right]<br>  \right)<br>$$</p>
<p>坐标转换分为几个阶段。</p>
<ol>
<li>Model</li>
<li>View</li>
<li>Projection</li>
<li>Viewport</li>
</ol>
<p>Model 阶段是将模型从局部坐标系(object coordinates)插入到世界坐标系(world coordinates)中。<br>View 阶段将世界坐标系映射到眼坐标系(eye coordinates)。<br>Projection将三维坐标投影在z=0的平面(clip coordinates)上。<br>Viewport将投影后的平面转换到屏幕的坐标系(sceen coordinates)中。</p>
<p>局部坐标系用于模型构建。<br>世界坐标系用于场景构建。</p>
<p>眼坐标系是从眼中看到的景象。眼坐标使得眼(相机)永远在眼坐标的z轴上，且可以定义一个向量用于指定最终看到镜像的垂直方向。<br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookat</span><span class="params">(Vec3f eye, Vec3f center, Vec3f up)</span> </span>&#123;</span><br><span class="line">    Vec3f z = (eye-center).normalize();</span><br><span class="line">    Vec3f x = cross(up,z).normalize();</span><br><span class="line">    Vec3f y = cross(z,x).normalize();</span><br><span class="line">    Matrix Minv = Matrix::identity();</span><br><span class="line">    Matrix Tr   = Matrix::identity();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">        Minv[<span class="number">0</span>][i] = x[i];</span><br><span class="line">        Minv[<span class="number">1</span>][i] = y[i];</span><br><span class="line">        Minv[<span class="number">2</span>][i] = z[i];</span><br><span class="line">        Tr[i][<span class="number">3</span>] = -center[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ModelView = Minv*Tr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>屏幕坐标系是我们实际在屏幕的坐标，以屏幕中心为原点。之前我们在代码中通过下面表达式转换坐标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen_coords[j] = Vec2i((v.x+<span class="number">1.</span>)*width/<span class="number">2.</span>, (v.y+<span class="number">1.</span>)*height/<span class="number">2.</span>);</span><br></pre></td></tr></table></figure>

<p>写成矩阵形式的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">viewport</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    Matrix m = Matrix::identity(<span class="number">4</span>);</span><br><span class="line">    m[<span class="number">0</span>][<span class="number">3</span>] = x+w/<span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">3</span>] = y+h/<span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">3</span>] = depth/<span class="number">2.f</span>;</span><br><span class="line"></span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = w/<span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">1</span>] = h/<span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">2</span>] = depth/<span class="number">2.f</span>;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的矩阵是<br>$$<br> \left[<br> \begin{matrix}<br>   w/2 &amp; 0 &amp; 0 &amp; x+w/2 \<br>   0 &amp; h/2 &amp; 0 &amp; y+h/2 \<br>   0 &amp; 0 &amp; d/2 &amp; d/2 \<br>   0 &amp; 0 &amp; r &amp; 1<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>其中d是深度缓冲的解析度。</p>
<p>通过上面的介绍， 我们将所有的变换串联起来。对于一个模型中的点v， 它的转换过程是</p>
<p>$$Viewport * Projection * View * Model * v$$</p>
<h3 id="法向量转换"><a href="#法向量转换" class="headerlink" title="法向量转换"></a>法向量转换</h3><p>设法向量n=(A,B,C), 则平面方程为Ax+By+Cz=0.写成齐次坐标的形式得到</p>
<p>$$<br>\left[<br>\begin{matrix}<br>A &amp;<br>B &amp;<br>C &amp;<br>0<br>\end{matrix}<br>\right] \times<br>\left[<br>\begin{matrix}<br>x \<br>y \<br>z \<br>1<br>\end{matrix}<br>\right]= 0<br>$$</p>
<p>在中间插入单位矩阵</p>
<p>$$<br>\left(<br>\left[<br>\begin{matrix}<br>A &amp;<br>B &amp;<br>C &amp;<br>0<br>\end{matrix}<br>\right]<br>\times<br>M^{-1}<br>\right) \times \left(<br>M \times<br>\left[<br>\begin{matrix}<br>x \<br>y \<br>z \<br>1<br>\end{matrix}<br>\right] \right) = 0<br>$$</p>
<p>重写上面的表达式</p>
<p>$$<br>\left(<br>(M^{T})^{-1} \times<br>\left[<br>\begin{matrix}<br>A \<br>B \<br>C \<br>0<br>\end{matrix}<br>\right]<br>\right)^{T} \times \left(<br>M \times<br>\left[<br>\begin{matrix}<br>x \<br>y \<br>z \<br>1<br>\end{matrix}<br>\right] \right) = 0<br>$$</p>
<p>所以法向量的转换矩阵为$(M^{T})^{-1}$</p>
<h2 id="着色器-shader"><a href="#着色器-shader" class="headerlink" title="着色器(shader)"></a>着色器(shader)</h2><p>整理下之前的渲染的过程,主要分为两步：</p>
<ol>
<li>顶点着色器(vertex shader), 主要目的是转换顶点的坐标。</li>
<li>片段着色器(fragment shader)，只要是确定像素的颜色。</li>
</ol>
<p>把这两部分从代码中抽取出来就可以实现各种不同的着色器。</p>
<h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><p>纹理保存的是三维模型表面的各类性质。它基本上可以存放任何东西，包括颜色，法向量，温度等等。</p>
<p>贴图是指将纹理映射到三维模型的表面上。</p>
<p>最常用的贴图可能是漫反射贴图。漫反射贴图中的纹理保存的是物体倍光照射后体现的颜色和光强度。</p>
<p>另外法向量也可以保存在纹理中。在之前的渲染中，法向量是通过三角形的三个顶点算出来的。也就是说，某一个点的法向量的准确性取决于模型的质量（三角形的多少）。</p>
<p>为了计算的效率，我们往往不会渲染一些高质量模型，而是通过高质量模型算出其法向量纹理。在低质量模型上，通过插值的方式，算出每个点的纹理坐标，在纹理中直接获取准确的法向量。</p>
<p>高光贴图是表现物体表面光滑程度的贴图。</p>
<p>在Phong反射模型中，一个点的局部光强由环境光，漫反射光和和高光组成。</p>
<p><img src="phong.png" alt="phong.png"></p>
<p>环境光是环境中大量光源在物体表面形成的光。它的光强现在假设在各个点上是均匀的，用常熟表示。</p>
<p>漫反射光是光向量和法线向量的内积。它假设光在各个方向是被均匀反射的。</p>
<p>至于光滑表面的高光，它应该遵循光的反射定律。由反射光向量和观察方向的单位向量的内积决定。</p>
<p>反射光可以如下计算</p>
<p>$$r = 2n&lt;n,l&gt; - l$$</p>
<p>其中n是法向量，l是光向量。</p>
<p>在光滑表面上，高光在反射光在反射方向上比其他方向要强得多。这种快速变化可以用指数函数模拟。底是反射光在观察方向的投影。指数反应物体表面的光滑程度，保存在高光纹理中。</p>
<p>下面是一个着色器，它在里面就用了高光贴图 $model-&gt;specular(uv)$ ，法向量贴图 $model-&gt;normal(uv)$ 和漫反射贴图 $model-&gt;diffuse(uv)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shader</span> :</span> <span class="keyword">public</span> IShader &#123;</span><br><span class="line">    mat&lt;<span class="number">2</span>,<span class="number">3</span>,<span class="keyword">float</span>&gt; varying_uv;  <span class="comment">// same as above</span></span><br><span class="line">    mat&lt;<span class="number">4</span>,<span class="number">4</span>,<span class="keyword">float</span>&gt; uniform_M;   <span class="comment">//  Projection*ModelView</span></span><br><span class="line">    mat&lt;<span class="number">4</span>,<span class="number">4</span>,<span class="keyword">float</span>&gt; uniform_MIT; <span class="comment">// (Projection*ModelView).invert_transpose()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec4f <span class="title">vertex</span><span class="params">(<span class="keyword">int</span> iface, <span class="keyword">int</span> nthvert)</span> </span>&#123;</span><br><span class="line">        varying_uv.set_col(nthvert, model-&gt;uv(iface, nthvert));</span><br><span class="line">        Vec4f gl_Vertex = embed&lt;<span class="number">4</span>&gt;(model-&gt;vert(iface, nthvert)); <span class="comment">// read the vertex from .obj file</span></span><br><span class="line">        <span class="keyword">return</span> Viewport*Projection*ModelView*gl_Vertex; <span class="comment">// transform it to screen coordinates</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">fragment</span><span class="params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class="line">        Vec2f uv = varying_uv*bar;</span><br><span class="line">        Vec3f n = proj&lt;<span class="number">3</span>&gt;(uniform_MIT*embed&lt;<span class="number">4</span>&gt;(model-&gt;normal(uv))).normalize();</span><br><span class="line">        Vec3f l = proj&lt;<span class="number">3</span>&gt;(uniform_M  *embed&lt;<span class="number">4</span>&gt;(light_dir        )).normalize();</span><br><span class="line">        Vec3f r = (n*(n*l*<span class="number">2.f</span>) - l).normalize();   <span class="comment">// reflected light</span></span><br><span class="line">        <span class="keyword">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">std</span>::max(r.z, <span class="number">0.0f</span>), model-&gt;specular(uv));</span><br><span class="line">        <span class="keyword">float</span> diff = <span class="built_in">std</span>::max(<span class="number">0.f</span>, n*l);</span><br><span class="line">        TGAColor c = model-&gt;diffuse(uv);</span><br><span class="line">        color = c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) color[i] = <span class="built_in">std</span>::min&lt;<span class="keyword">float</span>&gt;(<span class="number">5</span> + c[i]*(diff + <span class="number">.6</span>*spec), <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>至此，我们还没有考虑到阴影。其本质是观察物体上的点和光源之间有没有被物体上其他的点遮挡。</p>
<p>关于遮挡的问题让我们想到了z-buffer.只要我们把观察点放在光源的位置。先进行一次渲染，就能得到每个点到光源的深度信息。当然这次渲染只是为了获得光源的深度信息，并不实际作图。</p>
<p>最后我们再用第二个着色器对模型进行渲染。此时在片段着色器中，根据第一次渲染获得的光源深度信息，添加阴影相关代码。</p>
<p>两次的着色器代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DepthShader</span> :</span> <span class="keyword">public</span> IShader &#123;</span><br><span class="line">    mat&lt;<span class="number">3</span>,<span class="number">3</span>,<span class="keyword">float</span>&gt; varying_tri;</span><br><span class="line"></span><br><span class="line">    DepthShader() : varying_tri() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec4f <span class="title">vertex</span><span class="params">(<span class="keyword">int</span> iface, <span class="keyword">int</span> nthvert)</span> </span>&#123;</span><br><span class="line">        Vec4f gl_Vertex = embed&lt;<span class="number">4</span>&gt;(model-&gt;vert(iface, nthvert)); <span class="comment">// read the vertex from .obj file</span></span><br><span class="line">        gl_Vertex = Viewport*Projection*ModelView*gl_Vertex;          <span class="comment">// transform it to screen coordinates</span></span><br><span class="line">        varying_tri.set_col(nthvert, proj&lt;<span class="number">3</span>&gt;(gl_Vertex/gl_Vertex[<span class="number">3</span>]));</span><br><span class="line">        <span class="keyword">return</span> gl_Vertex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">fragment</span><span class="params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class="line">        Vec3f p = varying_tri*bar;</span><br><span class="line">        color = TGAColor(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)*(p.z/depth);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shader</span> :</span> <span class="keyword">public</span> IShader &#123;</span><br><span class="line">    mat&lt;<span class="number">4</span>,<span class="number">4</span>,<span class="keyword">float</span>&gt; uniform_M;   <span class="comment">//  Projection*ModelView</span></span><br><span class="line">    mat&lt;<span class="number">4</span>,<span class="number">4</span>,<span class="keyword">float</span>&gt; uniform_MIT; <span class="comment">// (Projection*ModelView).invert_transpose()</span></span><br><span class="line">    mat&lt;<span class="number">4</span>,<span class="number">4</span>,<span class="keyword">float</span>&gt; uniform_Mshadow; <span class="comment">// transform framebuffer screen coordinates to shadowbuffer screen coordinates</span></span><br><span class="line">    mat&lt;<span class="number">2</span>,<span class="number">3</span>,<span class="keyword">float</span>&gt; varying_uv;  <span class="comment">// triangle uv coordinates, written by the vertex shader, read by the fragment shader</span></span><br><span class="line">    mat&lt;<span class="number">3</span>,<span class="number">3</span>,<span class="keyword">float</span>&gt; varying_tri; <span class="comment">// triangle coordinates before Viewport transform, written by VS, read by FS</span></span><br><span class="line"></span><br><span class="line">    Shader(Matrix M, Matrix MIT, Matrix MS) : uniform_M(M), uniform_MIT(MIT), uniform_Mshadow(MS), varying_uv(), varying_tri() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec4f <span class="title">vertex</span><span class="params">(<span class="keyword">int</span> iface, <span class="keyword">int</span> nthvert)</span> </span>&#123;</span><br><span class="line">        varying_uv.set_col(nthvert, model-&gt;uv(iface, nthvert));</span><br><span class="line">        Vec4f gl_Vertex = Viewport*Projection*ModelView*embed&lt;<span class="number">4</span>&gt;(model-&gt;vert(iface, nthvert));</span><br><span class="line">        varying_tri.set_col(nthvert, proj&lt;<span class="number">3</span>&gt;(gl_Vertex/gl_Vertex[<span class="number">3</span>]));</span><br><span class="line">        <span class="keyword">return</span> gl_Vertex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">fragment</span><span class="params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class="line">        Vec4f sb_p = uniform_Mshadow*embed&lt;<span class="number">4</span>&gt;(varying_tri*bar); <span class="comment">// corresponding point in the shadow buffer</span></span><br><span class="line">        sb_p = sb_p/sb_p[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="keyword">int</span>(sb_p[<span class="number">0</span>]) + <span class="keyword">int</span>(sb_p[<span class="number">1</span>])*width; <span class="comment">// index in the shadowbuffer array</span></span><br><span class="line">        <span class="keyword">float</span> shadow = <span class="number">.3</span>+<span class="number">.7</span>*(shadowbuffer[idx]&lt;sb_p[<span class="number">2</span>]); </span><br><span class="line">        Vec2f uv = varying_uv*bar;                 <span class="comment">// interpolate uv for the current pixel</span></span><br><span class="line">        Vec3f n = proj&lt;<span class="number">3</span>&gt;(uniform_MIT*embed&lt;<span class="number">4</span>&gt;(model-&gt;normal(uv))).normalize(); <span class="comment">// normal</span></span><br><span class="line">        Vec3f l = proj&lt;<span class="number">3</span>&gt;(uniform_M  *embed&lt;<span class="number">4</span>&gt;(light_dir        )).normalize(); <span class="comment">// light vector</span></span><br><span class="line">        Vec3f r = (n*(n*l*<span class="number">2.f</span>) - l).normalize();   <span class="comment">// reflected light</span></span><br><span class="line">        <span class="keyword">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">std</span>::max(r.z, <span class="number">0.0f</span>), model-&gt;specular(uv));</span><br><span class="line">        <span class="keyword">float</span> diff = <span class="built_in">std</span>::max(<span class="number">0.f</span>, n*l);</span><br><span class="line">        TGAColor c = model-&gt;diffuse(uv);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) color[i] = <span class="built_in">std</span>::min&lt;<span class="keyword">float</span>&gt;(<span class="number">20</span> + c[i]*shadow*(<span class="number">1.2</span>*diff + <span class="number">.6</span>*spec), <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="环境光遮蔽（Ambient-occlusion）"><a href="#环境光遮蔽（Ambient-occlusion）" class="headerlink" title="环境光遮蔽（Ambient occlusion）"></a>环境光遮蔽（Ambient occlusion）</h2><p>在之前的章节中，我们将环境光选取为常数。这是一个很强的假设，它意味着场景中所有的光被平均反射到所有地方。</p>
<p>为了获取更接近于现实的图片，我们可以采用一些更需要计算的方法。</p>
<h3 id="暴力方法"><a href="#暴力方法" class="headerlink" title="暴力方法"></a>暴力方法</h3><p>我们可以假设我们的物体被一个半圆为主，并在半圆上由上千个顶点发出光。我们每个光源都像计算阴影一样计算它的可见性。最后再叠加起来求平均值并放入纹理中。</p>
<p>那么在实际渲染时环境光就能从纹理中获取。</p>
<p>这个方法是预计算的方法，虽然需要渲染很多次，但是只要纹理渲染出来了，我们就能在实际渲染时直接使用。</p>
<h3 id="屏幕空间环境光遮蔽"><a href="#屏幕空间环境光遮蔽" class="headerlink" title="屏幕空间环境光遮蔽"></a>屏幕空间环境光遮蔽</h3><p>现在介绍的方法是计算每个像素点的在各个方向上的最大仰角。</p>
<p>首先，我们同样先要渲染一编模型，获取z-buffer。</p>
<p>然后，在第二次渲染时，从像素点上下左右和四个斜方向分别计算仰角。</p>
<p>在特定方向上，每次取附近一个点，通过z-buffer值以及两个点的距离计算仰角大小。多次计算后选取仰角最大的一个。</p>
<p>最后，将个方向的最大仰角求平均值。通过这个值我们就能得到该点环境光的遮蔽程度（凹的程度）。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><span id="jump">1. <a target="_blank" rel="noopener" href="https://github.com/ssloy/tinyrenderer/wiki">https://github.com/ssloy/tinyrenderer/wiki</a></span></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">方镇澎</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://fzp.github.io/2020/03/23/2020-3-24-how-openGL-works/">http://fzp.github.io/2020/03/23/2020-3-24-how-openGL-works/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/openGL/">openGL</a><a class="post-meta__tags" href="/tags/graphics/">graphics</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/11/02/2020-11-3-css-layout-guide/"><i class="fa fa-chevron-left">  </i><span>CSS 布局漫游</span></a></div><div class="next-post pull-right"><a href="/2020/03/09/2020-3-10-compute-quantile/"><span>How to compute quantile effeciently</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2022 By 方镇澎</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.3"></script><script src="/js/fancybox.js?version=1.9.3"></script><script src="/js/sidebar.js?version=1.9.3"></script><script src="/js/copy.js?version=1.9.3"></script><script src="/js/fireworks.js?version=1.9.3"></script><script src="/js/transition.js?version=1.9.3"></script><script src="/js/scroll.js?version=1.9.3"></script><script src="/js/head.js?version=1.9.3"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>