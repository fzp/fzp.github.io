<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Sentry 后端监控SDK分析"><meta name="keywords" content="后端监控,Sentry"><meta name="author" content="方镇澎"><meta name="copyright" content="方镇澎"><title>Sentry 后端监控SDK分析 | 方镇澎的博客</title><link rel="shortcut icon" href="/favicon.svg"><link rel="stylesheet" href="/css/index.css?version=1.9.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.3"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">代码架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-SDK"><span class="toc-number">2.</span> <span class="toc-text">Java SDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot-SDK"><span class="toc-number">3.</span> <span class="toc-text">Spring Boot SDK</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SentryLogbackAppenderAutoConfiguration"><span class="toc-number">3.1.</span> <span class="toc-text">SentryLogbackAppenderAutoConfiguration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SentryAutoConfiguration"><span class="toc-number">3.2.</span> <span class="toc-text">SentryAutoConfiguration</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.1.</span> <span class="toc-text">Spring MVC相关对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#performance%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.</span> <span class="toc-text">performance相关对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="toc-number">3.4.</span> <span class="toc-text">传输对象工厂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">回答问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E9%94%99%E8%AF%AF%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">如何收集错误？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">如何收集性能数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E8%B7%AF%E5%BE%84%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">如何追踪路径？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">什么时候发送数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">怎么发送数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95Sentry-SDK%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">如何扩展Sentry SDK？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">方镇澎</div><div class="author-info__description text-center">方镇澎 Blog Slides</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">20</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">34</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">方镇澎的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Sentry 后端监控SDK分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-16</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本章从<a target="_blank" rel="noopener" href="https://github.com/getsentry/sentry-java">源码</a>出发探讨后端监控SDK的原理，主要集中在Java SDK和Spring Boot SDK.</p>
<p>并回答以下问题：</p>
<ol>
<li>如何收集错误？</li>
<li>如何收集性能数据？</li>
<li>如何追踪路径？</li>
<li>什么时候发送数据？</li>
<li>怎么发送数据？</li>
<li>如何扩展Sentry SDK？</li>
</ol>
<a id="more"></a>

<h2 id="代码架构"><a href="#代码架构" class="headerlink" title="代码架构"></a>代码架构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|- sentry-spring</span><br><span class="line">|- sentry-spring-boot-starter</span><br><span class="line">|- sentry-logback</span><br><span class="line">|- sentry</span><br></pre></td></tr></table></figure>

<p>Sentry SDK的代码分为多个模块，放在Github仓库的根目录下。</p>
<ul>
<li>sentry-spring-boot-starter在sentry-spring的基础上提供了跟mvc框架相关的插装项。</li>
<li>sentry-spring提供对spring框架的插装（Instumentation）。</li>
<li>sentry-logback提供了对日志系统logback的插装。</li>
<li>sentry提供接口定义，基本的类和方法。</li>
</ul>
<h2 id="Java-SDK"><a href="#Java-SDK" class="headerlink" title="Java SDK"></a>Java SDK</h2><p>有了之前分析前端SDK的经验，很多术语已经比较熟悉了。比如Hub, Scope, Event, Breadcrumbs, Transaction, Span等。</p>
<ul>
<li>Event：收集的异常。</li>
<li>Hub: 将异常发送到Sentry的地方。</li>
<li>Scope: Event相关的上下文和Breadcrumbs。</li>
<li>Breadcrumbs: 异常发生前的事情。</li>
<li>Tansaction: 用于性能追踪的操作记录。</li>
<li>Span: transaction树的节点。</li>
</ul>
<p>Java SDK实现了上述的数据结构。在任何Java项目里，都可以导入<a target="_blank" rel="noopener" href="https://docs.sentry.io/platforms/java/">Sentry Java SDK</a>。手动上传Event和Transaction。</p>
<h2 id="Spring-Boot-SDK"><a href="#Spring-Boot-SDK" class="headerlink" title="Spring Boot SDK"></a>Spring Boot SDK</h2><p>有了框架，就可以利用框架提供的接口自动上传异常和性能数据。</p>
<p>在初始化阶段，只需在<code>application.properties</code> 或 <code>application.yml</code>里添加配置信息即可。这些配置信息会自动注入到相应的对象中。</p>
<p>它的实现原理是利用了<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.18.RELEASE/reference/html/boot-features-developing-auto-configuration.html">Spring Boot Starter自动装配</a>的特性。</p>
<blockquote>
<p>SpringBoot 定义了一套接口规范，SpringBoot 在启动时会扫描外部引用 jar 包中的META-INF/spring.factories文件，将文件中配置的类型信息加载到 Spring 容器。</p>
</blockquote>
<p>查看<code>META-INF/spring.factories</code>.两个自动装配入口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">io.sentry.spring.boot.SentryAutoConfiguration,\</span><br><span class="line">io.sentry.spring.boot.SentryLogbackAppenderAutoConfiguration</span><br></pre></td></tr></table></figure>

<h3 id="SentryLogbackAppenderAutoConfiguration"><a href="#SentryLogbackAppenderAutoConfiguration" class="headerlink" title="SentryLogbackAppenderAutoConfiguration"></a>SentryLogbackAppenderAutoConfiguration</h3><p>查看<code>SentryLogbackAppenderAutoConfiguration</code>，创建了SentryLogbackInitializer对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@NotNull</span> <span class="function">SentryLogbackInitializer <span class="title">sentryLogbackInitializer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="meta">@NotNull</span> SentryProperties sentryProperties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SentryLogbackInitializer(sentryProperties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SentryLogbackInitializer实现了<code>GenericApplicationListener</code>接口。实际上是监听Spring的<code>ContextRefreshedEvent</code>事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(<span class="keyword">final</span> <span class="meta">@NotNull</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> eventType.getRawClass() != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; ContextRefreshedEvent.class.isAssignableFrom(eventType.getRawClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该事件在Spring容器里所有对象都实例化后触发。事件被捕捉后调用SentryLogbackInitializer的<code>onApplicationEvent()</code>. 在该方法里首先创建了SentryAppender。Appender在LogBack概念里是将日志事件发送到目的地的，sentryAppender就是将日志发送到Sentry。然后调用<code>sentryAppender.start()</code>对Sentry进行了初始化，最后将sentryAppender加入到logger。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(<span class="keyword">final</span> <span class="meta">@NotNull</span> ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Logger rootLogger = (Logger) LoggerFactory.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> SentryAppender sentryAppender = <span class="keyword">new</span> SentryAppender();</span><br><span class="line">    ...</span><br><span class="line">    sentryAppender.start();</span><br><span class="line">    rootLogger.addAppender(sentryAppender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当logger接收到事件时，会触发appender里的append方法。根据日志的级别，会发送日志或者将日志放入到BreadCrumbs。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="meta">@NotNull</span> ILoggingEvent eventObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eventObject.getLevel().isGreaterOrEqual(minimumEventLevel)) &#123;</span><br><span class="line">      Sentry.captureEvent(createEvent(eventObject));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eventObject.getLevel().isGreaterOrEqual(minimumBreadcrumbLevel)) &#123;</span><br><span class="line">      Sentry.addBreadcrumb(createBreadcrumb(eventObject));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SentryAutoConfiguration"><a href="#SentryAutoConfiguration" class="headerlink" title="SentryAutoConfiguration"></a>SentryAutoConfiguration</h3><p>回到另一个配置入口SentryAutoConfiguration。它创建了Hub对象，Spring MVC相关对象， performance相关对象，传输对象工厂等。Hub对象用于捕捉和发送异常，之前Hub在前端SDK中已经分析过，基本逻辑是一致的。Spring MVC和performance相关对象是收集数据用的。传输对象工厂用于创建发送到Sentry的客户端。</p>
<h4 id="Spring-MVC相关对象"><a href="#Spring-MVC相关对象" class="headerlink" title="Spring MVC相关对象"></a>Spring MVC相关对象</h4><p>Spring MVC相关对象主要有SentryRequestResolver, SentrySpringRequestListener, SentryExceptionResolver, SentryTracingFilter.</p>
<p>SentryRequestResolver主要是获取Http request相关信息并记录下来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NotNull</span> <span class="function">Request <span class="title">resolveSentryRequest</span><span class="params">(<span class="keyword">final</span> <span class="meta">@NotNull</span> HttpServletRequest httpRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Request sentryRequest = <span class="keyword">new</span> Request();</span><br><span class="line">    sentryRequest.setMethod(httpRequest.getMethod());</span><br><span class="line">    sentryRequest.setQueryString(httpRequest.getQueryString());</span><br><span class="line">    sentryRequest.setUrl(httpRequest.getRequestURL().toString());</span><br><span class="line">    sentryRequest.setHeaders(resolveHeadersMap(httpRequest));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hub.getOptions().isSendDefaultPii()) &#123;</span><br><span class="line">        sentryRequest.setCookies(toString(httpRequest.getHeaders(<span class="string">&quot;Cookie&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sentryRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SentrySpringRequestListener实现了ServletRequestListener用于监听http请求。它主要用于初始化scope，添加breadscrumb并将前面的SentryRequestResolver加到scope的事件处理器中。事件处理器会在捕捉到错误的执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">    hub.pushScope();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ServletRequest servletRequest = sre.getServletRequest();</span><br><span class="line">    <span class="keyword">if</span> (servletRequest <span class="keyword">instanceof</span> HttpServletRequest) &#123;</span><br><span class="line">        <span class="keyword">final</span> HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();</span><br><span class="line">        hub.addBreadcrumb(Breadcrumb.http(request.getRequestURI(), request.getMethod()));</span><br><span class="line"></span><br><span class="line">        hub.configureScope(</span><br><span class="line">            scope -&gt; &#123;</span><br><span class="line">            scope.addEventProcessor(</span><br><span class="line">                <span class="keyword">new</span> SentryRequestHttpServletRequestProcessor(request, requestResolver));</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SentryExceptionResolver实现了HandlerExceptionResolver从而捕捉Spring Boot全局异常，最后通过<code>hub.captureEvent(event)</code>发送给Sentry.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">ModelAndView <span class="title">resolveException</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="meta">@NotNull</span> HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="meta">@NotNull</span> HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="meta">@Nullable</span> Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="meta">@NotNull</span> Exception ex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Mechanism mechanism = <span class="keyword">new</span> Mechanism();</span><br><span class="line">    mechanism.setHandled(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">final</span> Throwable throwable =</span><br><span class="line">        <span class="keyword">new</span> ExceptionMechanismException(mechanism, ex, Thread.currentThread());</span><br><span class="line">    <span class="keyword">final</span> SentryEvent event = <span class="keyword">new</span> SentryEvent(throwable);</span><br><span class="line">    event.setLevel(SentryLevel.FATAL);</span><br><span class="line">    event.setTransaction(transactionNameProvider.provideTransactionName(request));</span><br><span class="line">    hub.captureEvent(event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// null = run other HandlerExceptionResolvers to actually handle the exception</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SentryTracingFilter通过FilterRegistrationBean注册了一个Servelt的过滤器。并且拥有最高优先级。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;sentry.enable-tracing&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;sentryTracingFilter&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;SentryTracingFilter&gt; <span class="title">sentryTracingFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="meta">@NotNull</span> IHub hub, <span class="keyword">final</span> <span class="meta">@NotNull</span> SentryRequestResolver sentryRequestResolver)</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean&lt;SentryTracingFilter&gt; filter =</span><br><span class="line">        <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;(<span class="keyword">new</span> SentryTracingFilter(hub, sentryRequestResolver));</span><br><span class="line">    filter.setOrder(Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    <span class="keyword">return</span> filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从@ConditionalOnProperty注解可知，SentryTracingFilter只有在<code>sentry.enable-tracing=true</code>的时候才创建。</p>
<p>下面代码里的doFilterInternal是SentryTracingFilter的过滤器逻辑。它的作用是开启一个transaction，并在执行完所有filter后（包括业务代码）关闭transaction。<code>finish()</code>里面调用了<code>hub.captureTransaction(transaction);</code> 将transation发送给Sentry.</p>
<p>另外，注意到代码里从头文件中取出了sentryTraceHeader。这是前端传过来的trace Id, 如果前端也配有Sentry,那么前后端的性能监控就能连结起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> String sentryTraceHeader = httpRequest.getHeader(SentryTraceHeader.SENTRY_TRACE_HEADER);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> ITransaction transaction = startTransaction(httpRequest, sentryTraceHeader);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        filterChain.doFilter(httpRequest, httpResponse);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// after all filters run, templated path pattern is available in request attribute</span></span><br><span class="line">        <span class="keyword">final</span> String transactionName = transactionNameProvider.provideTransactionName(httpRequest);</span><br><span class="line">        <span class="comment">// if transaction name is not resolved, the request has not been processed by a controller</span></span><br><span class="line">        <span class="comment">// and</span></span><br><span class="line">        <span class="comment">// we should not report it to Sentry</span></span><br><span class="line">        <span class="keyword">if</span> (transactionName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            transaction.setName(transactionName);</span><br><span class="line">            transaction.setOperation(TRANSACTION_OP);</span><br><span class="line">            transaction.setStatus(SpanStatus.fromHttpStatusCode(httpResponse.getStatus()));</span><br><span class="line">            transaction.finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="performance相关对象"><a href="#performance相关对象" class="headerlink" title="performance相关对象"></a>performance相关对象</h3><p>此处引入了Spring 配置类<code>SentryTransactionPointcutConfiguration</code>和<code>SentrySpanPointcutConfiguration</code>。它们分别定义@SentryTransaction和@SentrySpan注解的切点。同时还导入了<code>SentryAdviceConfiguration</code>配置类，定义了处理切点行为的类sentryTransactionAdvice和SentrySpanAdvice。</p>
<p>以<code>SentrySpanPointcutConfiguration</code>为例。它定义了两类切点，一类是Class上带有@SentrySpan的方法。另一类是直接带有@SentrySpan的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@NotNull</span> <span class="function">Pointcut <span class="title">sentrySpanPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ComposablePointcut(<span class="keyword">new</span> AnnotationClassFilter(SentrySpan.class, <span class="keyword">true</span>))</span><br><span class="line">        .union(<span class="keyword">new</span> AnnotationMatchingPointcut(<span class="keyword">null</span>, SentrySpan.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理@SentrySpan的行为定义在SentrySpanAdvice。他的主要作用是将该函数的调用以span方式记录到transaction里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String operation = resolveSpanOperation(targetClass, mostSpecificMethod, sentrySpan);</span><br><span class="line"><span class="keyword">final</span> ISpan span = activeSpan.startChild(operation);</span><br></pre></td></tr></table></figure>

<p>另外，对于@SentryTransaction. 如果已经有活跃的transaction, @SentryTransaction不会启动一个新的transaction.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isTransactionActive) &#123;</span><br><span class="line">    <span class="comment">// transaction is already active, we do not start new transaction</span></span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传输对象工厂"><a href="#传输对象工厂" class="headerlink" title="传输对象工厂"></a>传输对象工厂</h3><p>传输对象工厂会创建ApacheHttpClientTransport，该对象利用CloseableHttpAsyncClient发送请求。异步请求不会阻塞原来的业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ITransport <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="meta">@NotNull</span> SentryOptions options, <span class="keyword">final</span> <span class="meta">@NotNull</span> RequestDetails requestDetails)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(options, <span class="string">&quot;options is required&quot;</span>);</span><br><span class="line">    Objects.requireNonNull(requestDetails, <span class="string">&quot;requestDetails is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> PoolingAsyncClientConnectionManager connectionManager =</span><br><span class="line">        PoolingAsyncClientConnectionManagerBuilder.create()</span><br><span class="line">            .setPoolConcurrencyPolicy(PoolConcurrencyPolicy.LAX)</span><br><span class="line">            .setConnectionTimeToLive(connectionTimeToLive)</span><br><span class="line">            .setMaxConnTotal(options.getMaxQueueSize())</span><br><span class="line">            .setMaxConnPerRoute(options.getMaxQueueSize())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CloseableHttpAsyncClient httpclient =</span><br><span class="line">        HttpAsyncClients.custom()</span><br><span class="line">            .setKeepAliveStrategy(DefaultConnectionKeepAliveStrategy.INSTANCE)</span><br><span class="line">            .setConnectionManager(connectionManager)</span><br><span class="line">            .setConnectionReuseStrategy(DefaultConnectionReuseStrategy.INSTANCE)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RateLimiter rateLimiter = <span class="keyword">new</span> RateLimiter(options.getLogger());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApacheHttpClientTransport(options, requestDetails, httpclient, rateLimiter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h2><p>现在基本摸清了Sentry后端SDK的代码。回到我们前面提到的问题。</p>
<h3 id="如何收集错误？"><a href="#如何收集错误？" class="headerlink" title="如何收集错误？"></a>如何收集错误？</h3><p>对于Java, 利用sentry提供的方法手动收集。</p>
<p>对于Spring Boot, 一是利用它提供的HandlerExceptionResolver捕捉全局异常。 二是利用日志系统的收集。</p>
<h3 id="如何收集性能数据？"><a href="#如何收集性能数据？" class="headerlink" title="如何收集性能数据？"></a>如何收集性能数据？</h3><p>对于Java, 手动收集。</p>
<p>对于Spring Boot, 一是利用了Servlet的filter, 开启和完成transaction。二是通过手动标记@SentryTransaction和@SentrySpan注解。</p>
<h3 id="如何追踪路径？"><a href="#如何追踪路径？" class="headerlink" title="如何追踪路径？"></a>如何追踪路径？</h3><p>在日志系统里添加Breadcrumb.</p>
<p>利用Spring的AOP机制，跟据@SentryTransaction和@SentrySpan往Transaction里面添加Span。</p>
<h3 id="什么时候发送数据？"><a href="#什么时候发送数据？" class="headerlink" title="什么时候发送数据？"></a>什么时候发送数据？</h3><p>对于异常，一旦捕捉到就会发送。</p>
<p>对于性能数据，请求结束就会发送。</p>
<h3 id="怎么发送数据？"><a href="#怎么发送数据？" class="headerlink" title="怎么发送数据？"></a>怎么发送数据？</h3><p>Spring boot框架下默认使用CloseableHttpAsyncClient。</p>
<h3 id="如何扩展Sentry-SDK？"><a href="#如何扩展Sentry-SDK？" class="headerlink" title="如何扩展Sentry SDK？"></a>如何扩展Sentry SDK？</h3><p>在 Java 相关的SDK中也有Intregration的概念，但大多数用在了安卓端。在后端SDK中相对较少。如果在Spring boot中，利用Spring Boot Starter扩展就够了。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">方镇澎</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://fzp.github.io/2021/03/16/how-sentry-work-1/">http://fzp.github.io/2021/03/16/how-sentry-work-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF%E7%9B%91%E6%8E%A7/">后端监控</a><a class="post-meta__tags" href="/tags/Sentry/">Sentry</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/03/31/mysql.mm/"><i class="fa fa-chevron-left">  </i><span>mysql</span></a></div><div class="next-post pull-right"><a href="/2021/03/08/how-sentry-works/"><span>Sentry 前端监控SDK分析</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2022 By 方镇澎</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.3"></script><script src="/js/fancybox.js?version=1.9.3"></script><script src="/js/sidebar.js?version=1.9.3"></script><script src="/js/copy.js?version=1.9.3"></script><script src="/js/fireworks.js?version=1.9.3"></script><script src="/js/transition.js?version=1.9.3"></script><script src="/js/scroll.js?version=1.9.3"></script><script src="/js/head.js?version=1.9.3"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>